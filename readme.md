Описание
В этом проекте реализован собственный пул потоков — CustomThreadPool, написанный на Java. Основная цель — обеспечить эффективное выполнение множества параллельных задач с возможностью гибкой настройки поведения пула.

Анализ производительности
Сравнение со стандартными решениями (ThreadPoolExecutor)
Для оценки эффективности CustomThreadPool он был сопоставлен с ThreadPoolExecutor — стандартной реализацией пула потоков в Java. Тестирование охватывало два типа задач:

Задачи ввода-вывода (эмулировались с помощью Thread.sleep)

Вычислительно затратные задачи (работа с большими массивами данных)

Результаты:

Простые задачи: В случаях с легкими задачами ThreadPoolExecutor показывает чуть лучшие результаты благодаря встроенным оптимизациям.

Сложные задачи и блокировки: В условиях, где используются задержки или блокирующие операции, разница между двумя пулами минимальна.

Гибкость настройки: CustomThreadPool предоставляет более широкие возможности для конфигурации, включая параметры вроде minIdle, которые могут быть полезны в специфических сценариях.

Сравнение с пулами в Tomcat и Jetty
Прямое сравнение не проводилось, но стоит отметить, что пулы потоков в таких серверах, как Tomcat и Jetty, предназначены в первую очередь для обработки HTTP-запросов и имеют более продвинутые механизмы управления. В отличие от них, CustomThreadPool — более простая реализация, но этого может быть достаточно для общего использования вне веб-серверов.

Вывод:
CustomThreadPool — это сбалансированное решение между возможностью настройки и уровнем производительности. Если приоритетом является высокая производительность и минимальные накладные расходы — стоит использовать ThreadPoolExecutor. В случаях, когда важна гибкость и контроль, предпочтение можно отдать собственной реализации.

Исследование влияния параметров на производительность
Некоторые наблюдения, полученные при тестировании различных конфигураций CustomThreadPool:

coreThreads и maxThreads:
Увеличение coreThreads положительно влияет на производительность при стартовой нагрузке, а maxThreads позволяет системе масштабироваться под возросшую нагрузку. Однако чрезмерное увеличение maxThreads может привести к перегрузке из-за частых переключений контекста.

queueCapacity:
Слишком маленькая очередь приводит к отказам в приёме новых задач, а слишком большая — к задержкам и снижению отклика. Рекомендуется подбирать значение в зависимости от типа задач и частоты их поступления.

idleTimeout и minIdle:
Меньшее значение idleTimeout помогает быстрее освобождать ресурсы, но может вызывать задержки при создании новых потоков. Параметр minIdle фиксирует минимальное количество готовых к выполнению потоков. Его стоит подбирать аккуратно, чтобы избежать избыточного расхода ресурсов.

Механизм обработки задач
Задачи, поступающие через метод execute(), ставятся в очередь taskQueue. Потоки-работники (Worker) извлекают задачи из этой очереди и исполняют их. Выбор потока осуществляется по алгоритму round-robin, что обеспечивает относительно равномерное распределение задач.

Балансировка и ограничения
В текущей реализации отсутствует продвинутая логика балансировки нагрузки. Используемый подход работает хорошо при равномерной нагрузке, но может стать неэффективным, если задачи сильно отличаются по продолжительности. В этом случае может потребоваться внедрение более интеллектуального механизма учёта загруженности потоков, чего в данной версии не предусмотрено.

